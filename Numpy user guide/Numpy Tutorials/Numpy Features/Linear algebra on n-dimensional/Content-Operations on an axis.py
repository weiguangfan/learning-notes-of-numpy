"""
可以使用线性代数的方法来对现有的数据集进行近似。
在这里，我们将使用SVD（奇异值分解）来尝试重建一幅图像，它使用的奇异值信息比原来的少，同时还保留了一些特征。

注意：我们将使用NumPy的线性代数模块numpy.linalg来执行本教程中的操作。
这个模块中的大部分线性代数函数也可以在scipy.linalg中找到，我们鼓励用户在实际应用中使用scipy模块。
然而，scipy.linalg模块中的一些函数，如SVD函数，只支持二维数组。
关于这方面的更多信息，请查看 scipy.linalg Reference。

要继续，从NumPy中导入线性代数子模块。

"""
import numpy as np
from numpy import linalg
"""
为了从一个给定的矩阵中提取信息，我们可以使用SVD得到3个数组，这些数组可以相乘以得到原始矩阵。
从线性代数的理论来看，给定一个矩阵 ，可以计算出以下乘积。
"""
# np.dot(np.dot(U,sigma),V.T) = A

"""
其中U和V.T是正方形，sigma的大小与A相同。
sigma是一个对角线矩阵，包含从大到小排列的奇异值。
这些值总是非负的，可以作为矩阵A所代表的一些特征的 "重要性 "的指标。

让我们先看看这在实践中是如何使用一个矩阵的。
请注意，根据测色学，如果我们应用公式，就有可能获得我们的彩色图像的一个相当合理的灰度版本


"""
# Y = 0.2126R + 0.7152G + 0.0722B

"""
其中Y是代表灰度图像的数组，R , G和B是我们原来的红、绿、蓝通道数组。
注意我们可以使用@运算符（NumPy数组的矩阵乘法运算符，见numpy.matmul）来实现。
"""
from scipy import misc
img = misc.face()
img_array = img / 255
img_gray = img_array @ [0.2126,0.7152,0.0722]

"""
现在，img_gray具有形状
"""

print(img_gray.shape)

"""
为了看看这在我们的图像中是否有意义，我们应该使用matplotlib中与我们希望在图像中看到的颜色相对应的颜色映射（否则，matplotlib将默认为一个与真实数据不一致的颜色映射）。

在我们的例子中，我们要接近图像的灰度部分，所以我们将使用灰色的颜色映射。

"""
import matplotlib.pyplot as plt
plt.imshow(img_gray,cmap="grap")
plt.show()

"""
现在，对这个矩阵应用linalg.svd函数，我们得到以下分解。
"""
U,s,Vt = linalg.svd(img_gray)

"""
注意 
如果你使用的是你自己的镜像，这个命令可能需要一段时间来运行，这取决于你的镜像的大小和你的硬件。
不要担心，这很正常 
SVD可能是一个相当密集的计算。

让我们检查一下这是否与我们的预期相符。

"""
print(U.shape)
print(s.shape)
print(Vt.shape)
"""
请注意，s有一个特殊的形状：它只有一维。
这意味着一些期望二维数组的线性代数函数可能无法工作。
例如，从理论上讲，人们可能期望s和Vt的乘法是兼容的。
然而，这是不正确的，因为s没有第二个轴。
执行
"""
s @ Vt


